<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>作曲ツールv5（マス音階表示＆JSON入出力）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      padding: 20px;
      background-color: #f0f0f0;
    }
    .controls {
      margin-bottom: 20px;
    }
    .sequencer {
      display: grid;
      gap: 2px;
      margin: 20px auto;
      max-width: 1200px;
    }
    .note {
      width: 20px;
      height: 30px;
      border: 1px solid #ccc;
      background-color: #fff;
      cursor: pointer;
      font-size: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-sizing: border-box;
    }
    .note.active {
      background-color: #4caf50;
      color: white;
    }
    .note.rest {
      background-color: #d3d3d3;
      color: black;
    }
    .note.playing {
      border: 2px solid #ff5722;
      width: 20px;
      height: 30px;
    }
    .note.connected {
      background-color: #81c784;
      border-left: none;
      border-right: none;
      cursor: default;
      pointer-events: none;
    }
    .note.active.connected {
      background-color: #81c784;
    }
    .note.inactive-name {
      opacity: 0.5;
      font-size: 7px;
    }
    .note.step-boundary {
      border-right: 1px solid #999;
    }
    .note.measure-boundary {
      border-right: 2px solid #666;
    }
    .note.section-boundary {
      border-right: 3px solid #000;
    }
    .row-label {
      width: 80px;
      text-align: right;
      padding-right: 10px;
      font-size: 14px;
    }
    button, select, input {
      padding: 8px 16px;
      margin: 5px;
      font-size: 14px;
      cursor: pointer;
      background-color: #2196f3;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:hover, select:hover, input[type="checkbox"] + label:hover {
      background-color: #1976d2;
    }
    input[type="number"] {
      width: 80px;
      background-color: white;
      color: black;
    }
    input[type="checkbox"] {
      vertical-align: middle;
    }
    input[type="file"] {
      background-color: white;
      color: black;
      padding: 8px;
    }
    .context-menu {
      position: absolute;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      padding: 5px;
      width: 200px;
      max-height: 300px;
      overflow-y: auto;
    }
    .context-menu div {
      padding: 8px;
      cursor: pointer;
    }
    .context-menu div:hover {
      background-color: #f0f0f0;
    }
    .context-menu input {
      width: 60px;
      margin: 5px;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      width: 80%;
      max-width: 600px;
    }
    .modal-content textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>作曲ツールv5</h1>
  <p>グリッドをクリックで音を配置、右クリックで長さや休符を設定（クリック位置に表示）。1マス=32分音符、マスに音階名を表示。JSONで保存/読み込み、旧セーブコード読み込み可、ドラム自動コピー（新小節）可。</p>
  <div class="controls">
    <button onclick="playSequence()">再生</button>
    <button onclick="stopSequence()">停止</button>
    <button onclick="addMeasure()">小節追加</button>
    <button onclick="removeMeasure()">小節削除</button>
    <button onclick="saveSequence()">保存</button>
    <button onclick="loadSequence()">読み込み</button>
    <button onclick="exportJson()">JSONエクスポート</button>
    <button onclick="showJsonImportModal()">JSONインポート</button>
    <button onclick="showLoadCodeModal()">旧セーブコード読み込み</button>
    <button onclick="exportWav()">WAVエクスポート</button>
    <label>テンポ (BPM): <input type="number" id="tempo" value="120" min="30" max="300"></label>
    <label>デフォルト長さ (0.5ステップ単位): <input type="number" id="defaultDuration" value="4" min="0.5" max="2000" step="0.5"></label>
    <label>楽器: 
      <select id="instrument">
        <option value="sine">ピアノ (Sine)</option>
        <option value="square">バイオリン (Square)</option>
        <option value="sawtooth">ギター (Sawtooth)</option>
        <option value="triangle">フルート (Triangle)</option>
        <option value="trumpet">トランペット</option>
        <option value="bass">ベース</option>
        <option value="kick">バスドラム</option>
        <option value="snare">スネア</option>
        <option value="hihat">ハイハット</option>
        <option value="cymbal">シンバル</option>
        <option value="clap">クラップ</option>
        <option value="tom">タム</option>
        <option value="piccolo">ピッコロ</option>
        <option value="sax">サックス</option>
      </select>
    </label>
    <label><input type="checkbox" id="autoCopyDrums" checked> ドラム自動コピー（新小節）</label>
  </div>
  <div class="sequencer" id="sequencer"></div>
  <div class="modal" id="loadCodeModal">
    <div class="modal-content">
      <h2>旧セーブコード読み込み</h2>
      <textarea id="loadCodeInput" placeholder="旧セーブコード（Base64）を貼り付けてください"></textarea>
      <button onclick="loadFromCode()">読み込み</button>
      <button onclick="closeModal('loadCodeModal')">閉じる</button>
    </div>
  </div>
  <div class="modal" id="fileInputModal">
    <div class="modal-content">
      <h2>JSONインポート</h2>
      <input type="file" id="jsonFileInput" accept=".json">
      <button onclick="loadFromJson()">読み込み</button>
      <button onclick="closeModal('fileInputModal')">閉じる</button>
    </div>
  </div>

  <script>
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();
    const melodyNotes = [
      { name: "C3", freq: 130.81 },
      { name: "C#3/D♭3", freq: 138.59 },
      { name: "D3", freq: 146.83 },
      { name: "D#3/E♭3", freq: 155.56 },
      { name: "E3", freq: 164.81 },
      { name: "F3", freq: 174.61 },
      { name: "F#3/G♭3", freq: 185.00 },
      { name: "G3", freq: 196.00 },
      { name: "G#3/A♭3", freq: 207.65 },
      { name: "A3", freq: 220.00 },
      { name: "A#3/B♭3", freq: 233.08 },
      { name: "B3", freq: 246.94 },
      { name: "C4", freq: 261.63 },
      { name: "C#4/D♭4", freq: 277.18 },
      { name: "D4", freq: 293.66 },
      { name: "D#4/E♭4", freq: 311.13 },
      { name: "E4", freq: 329.63 },
      { name: "F4", freq: 349.23 },
      { name: "F#4/G♭4", freq: 369.99 },
      { name: "G4", freq: 392.00 },
      { name: "G#4/A♭4", freq: 415.30 },
      { name: "A4", freq: 440.00 },
      { name: "A#4/B♭4", freq: 466.16 },
      { name: "B4", freq: 493.88 },
      { name: "C5", freq: 523.25 },
      { name: "C#5/D♭5", freq: 554.37 },
      { name: "D5", freq: 587.33 },
      { name: "D#5/E♭5", freq: 622.25 },
      { name: "E5", freq: 659.25 },
      { name: "F5", freq: 698.46 },
      { name: "F#5/G♭5", freq: 739.99 },
      { name: "G5", freq: 783.99 },
      { name: "G#5/A♭5", freq: 830.61 },
      { name: "A5", freq: 880.00 },
      { name: "A#5/B♭5", freq: 932.33 },
      { name: "B5", freq: 987.77 },
      { name: "C6", freq: 1046.50 }
    ];
    const drumNotes = [
      { name: "Kick", type: "kick" },
      { name: "Snare", type: "snare" },
      { name: "HiHat", type: "hihat" },
      { name: "Cymbal", type: "cymbal" }
    ];
    const notes = [...melodyNotes, ...drumNotes];
    const instrumentTypes = {
      sine: { name: "Piano", type: "melody", wave: "sine", envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.2 } },
      square: { name: "Violin", type: "melody", wave: "square", envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.3 } },
      sawtooth: { name: "Guitar", type: "melody", wave: "sawtooth", vibrato: { freq: 5, depth: 0.1 } },
      triangle: { name: "Flute", type: "melody", wave: "triangle", filter: { type: "highpass", freq: 1000 }, vibrato: { freq: 4, depth: 0.05 } },
      trumpet: { name: "Trumpet", type: "melody", wave: "square", filter: { type: "bandpass", freq: 1200 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.2 } },
      bass: { name: "Bass", type: "melody", wave: "sine", filter: { type: "lowpass", freq: 300 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.3 } },
      kick: { name: "Kick", type: "drum" },
      snare: { name: "Snare", type: "drum" },
      hihat: { name: "HiHat", type: "drum" },
      cymbal: { name: "Cymbal", type: "drum" },
      clap: { name: "Clap", type: "drum" },
      tom: { name: "Tom", type: "drum" },
      piccolo: { name: "Piccolo", type: "melody", wave: "triangle", filter: { type: "lowpass", freq: 2000 } },
      sax: { name: "Sax", type: "melody", wave: "sawtooth", filter: { type: "lowpass", freq: 800 } }
    };
    let measures = 4;
    const stepsPerMeasure = 8;
    let defaultDuration = 4;
    let sequence = Array(notes.length).fill().map(() => 
      Array(measures * stepsPerMeasure).fill().map(() => ({ active: false, duration: defaultDuration, connected: false, rest: false }))
    );
    let isPlaying = false;
    let currentStep = 0;
    let nextNoteTime = 0;

    // ドラム自動コピーの設定保存
    document.getElementById('autoCopyDrums').addEventListener('change', () => {
      localStorage.setItem('autoCopyDrums', document.getElementById('autoCopyDrums').checked);
    });

    // ドラム自動コピー設定の復元
    const savedAutoCopy = localStorage.getItem('autoCopyDrums');
    if (savedAutoCopy !== null) {
      document.getElementById('autoCopyDrums').checked = savedAutoCopy === 'true';
    }

    // デフォルト長さの更新
    document.getElementById('defaultDuration').addEventListener('change', () => {
      const value = parseFloat(document.getElementById('defaultDuration').value);
      if (value >= 0.5 && value <= 2000) {
        defaultDuration = value;
        sequence = sequence.map(row => 
          row.map(cell => ({ ...cell, duration: cell.active || cell.rest ? cell.duration : defaultDuration }))
        );
      }
    });

    // JSONエクスポート
    function exportJson() {
      const data = { sequence, measures, defaultDuration };
      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sequence.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    // JSONインポートモーダル表示
    function showJsonImportModal() {
      document.getElementById('fileInputModal').style.display = 'flex';
    }

    // JSON読み込み
    function loadFromJson() {
      const input = document.getElementById('jsonFileInput');
      const file = input.files[0];
      if (!file) {
        alert('JSONファイルを選択してください。');
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          if (
            data.sequence && Array.isArray(data.sequence) &&
            (data.sequence.length === 17 || data.sequence.length === notes.length) &&
            data.measures && typeof data.measures === 'number' &&
            data.defaultDuration && typeof data.defaultDuration === 'number'
          ) {
            let newSequence = Array(notes.length).fill().map(() => 
              Array(data.measures * stepsPerMeasure).fill().map(() => ({ active: false, duration: data.defaultDuration, connected: false, rest: false }))
            );
            if (data.sequence.length === 17) {
              // 旧データ（C4～C5＋4ドラム）のマッピング
              for (let row = 0; row < 13; row++) {
                newSequence[row + 12] = data.sequence[row].map(cell => ({
                  active: !!cell.active,
                  duration: Number(cell.duration) || data.defaultDuration,
                  connected: !!cell.connected,
                  rest: !!cell.rest
                }));
              }
              for (let row = 13; row < 17; row++) {
                newSequence[row + 24] = data.sequence[row].map(cell => ({
                  active: !!cell.active,
                  duration: Number(cell.duration) || data.defaultDuration,
                  connected: !!cell.connected,
                  rest: !!cell.rest
                }));
              }
            } else {
              // 新データ（C3～C6＋4ドラム）
              newSequence = data.sequence.map(row => 
                row.map(cell => ({
                  active: !!cell.active,
                  duration: Number(cell.duration) || data.defaultDuration,
                  connected: !!cell.connected,
                  rest: !!cell.rest
                }))
              );
            }
            sequence = newSequence;
            measures = data.measures;
            defaultDuration = data.defaultDuration;
            document.getElementById('defaultDuration').value = defaultDuration;
            renderSequencer();
            closeModal('fileInputModal');
            alert('JSONを読み込みました！');
          } else {
            alert('無効なJSON形式です。データ構造を確認してください。');
          }
        } catch (e) {
          alert('JSONファイルの読み込みに失敗しました。ファイルが正しいか確認してください。');
        }
      };
      reader.readAsText(file);
    }

    // 旧セーブコード読み込み
    function showLoadCodeModal() {
      document.getElementById('loadCodeModal').style.display = 'flex';
    }

    function loadFromCode() {
      const textarea = document.getElementById('loadCodeInput');
      const saveCode = textarea.value.trim();
      try {
        const jsonString = atob(saveCode);
        const data = JSON.parse(jsonString);
        if (
          data.sequence && Array.isArray(data.sequence) &&
          (data.sequence.length === 17 || data.sequence.length === notes.length) &&
          data.measures && typeof data.measures === 'number' &&
          data.defaultDuration && typeof data.defaultDuration === 'number'
        ) {
          let newSequence = Array(notes.length).fill().map(() => 
            Array(data.measures * stepsPerMeasure).fill().map(() => ({ active: false, duration: data.defaultDuration, connected: false, rest: false }))
          );
          if (data.sequence.length === 17) {
            for (let row = 0; row < 13; row++) {
              newSequence[row + 12] = data.sequence[row].map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || data.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }));
            }
            for (let row = 13; row < 17; row++) {
              newSequence[row + 24] = data.sequence[row].map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || data.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }));
            }
          } else {
            newSequence = data.sequence.map(row => 
              row.map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || data.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }))
            );
          }
          sequence = newSequence;
          measures = data.measures;
          defaultDuration = data.defaultDuration;
          document.getElementById('defaultDuration').value = defaultDuration;
          renderSequencer();
          closeModal('loadCodeModal');
          alert('旧セーブコードを読み込みました！');
        } else {
          alert('無効なセーブコードです。データ形式を確認してください。');
        }
      } catch (e) {
        alert('セーブコードの読み込みに失敗しました。コードが正しいか確認してください。');
      }
    }

    // モーダル閉じる
    function closeModal(modalId) {
      document.getElementById(modalId).style.display = 'none';
    }

    // シーケンスの保存（ローカルストレージ）
    function saveSequence() {
      const data = { sequence, measures, defaultDuration };
      localStorage.setItem('musicComposerSequence', JSON.stringify(data));
      alert('シーケンスをローカルに保存しました！');
    }

    // シーケンスの読み込み（ローカルストレージ）
    function loadSequence() {
      const data = localStorage.getItem('musicComposerSequence');
      if (data) {
        const parsed = JSON.parse(data);
        if (
          parsed.sequence && Array.isArray(parsed.sequence) &&
          (parsed.sequence.length === 17 || parsed.sequence.length === notes.length) &&
          parsed.measures && typeof parsed.measures === 'number' &&
          parsed.defaultDuration && typeof parsed.defaultDuration === 'number'
        ) {
          let newSequence = Array(notes.length).fill().map(() => 
            Array(parsed.measures * stepsPerMeasure).fill().map(() => ({ active: false, duration: parsed.defaultDuration, connected: false, rest: false }))
          );
          if (parsed.sequence.length === 17) {
            for (let row = 0; row < 13; row++) {
              newSequence[row + 12] = parsed.sequence[row].map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || parsed.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }));
            }
            for (let row = 13; row < 17; row++) {
              newSequence[row + 24] = parsed.sequence[row].map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || parsed.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }));
            }
          } else {
            newSequence = parsed.sequence.map(row => 
              row.map(cell => ({
                active: !!cell.active,
                duration: Number(cell.duration) || parsed.defaultDuration,
                connected: !!cell.connected,
                rest: !!cell.rest
              }))
            );
          }
          sequence = newSequence;
          measures = parsed.measures;
          defaultDuration = parsed.defaultDuration;
          document.getElementById('defaultDuration').value = defaultDuration;
          renderSequencer();
          alert('ローカルからシーケンスを読み込みました！');
        } else {
          alert('保存されたシーケンスの形式が無効です。');
        }
      } else {
        alert('保存されたシーケンスがありません。');
      }
    }

    // WAVエクスポート
    async function exportWav() {
      const tempo = parseInt(document.getElementById('tempo').value) || 120;
      const stepDuration = 60 / tempo / 8;
      const totalDuration = measures * stepsPerMeasure * stepDuration;
      const offlineCtx = new OfflineAudioContext(2, Math.ceil(totalDuration * ctx.sampleRate), ctx.sampleRate);

      for (let row = 0; row < notes.length; row++) {
        for (let col = 0; col < measures * stepsPerMeasure; col++) {
          if (sequence[row][col].active && !sequence[row][col].rest) {
            const startTime = col * stepDuration;
            const duration = stepDuration * sequence[row][col].duration;
            const instrument = document.getElementById('instrument').value;
            await renderNote(notes[row], startTime, duration, instrument, offlineCtx);
          }
        }
      }

      const renderedBuffer = await offlineCtx.startRendering();
      const wav = audioBufferToWav(renderedBuffer);
      const blob = new Blob([wav], { type: 'audio/wav' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sequence.wav';
      a.click();
      URL.revokeObjectURL(url);
    }

    // AudioBufferをWAVに変換
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const length = buffer.length * numChannels * 2 + 44;
      const arrayBuffer = new ArrayBuffer(length);
      const view = new DataView(arrayBuffer);

      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * 2, true);
      view.setUint16(32, numChannels * 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, buffer.length * numChannels * 2, true);

      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          const sample = buffer.getChannelData(channel)[i];
          const value = Math.max(-1, Math.min(1, sample)) * 32767;
          view.setInt16(44 + (i * numChannels + channel) * 2, value, true);
        }
      }
      return arrayBuffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // シーケンサーグリッドの生成
    function renderSequencer() {
      const sequencer = document.getElementById('sequencer');
      sequencer.innerHTML = '';
      sequencer.style.gridTemplateColumns = `80px repeat(${measures * stepsPerMeasure}, 20px)`;
      
      for (let i = 0; i < notes.length; i++) {
        const label = document.createElement('div');
        label.classList.add('row-label');
        label.textContent = notes[i].name;
        sequencer.appendChild(label);

        for (let j = 0; j < measures * stepsPerMeasure; j++) {
          const note = document.createElement('div');
          note.classList.add('note');
          note.dataset.row = i;
          note.dataset.col = j;
          note.textContent = sequence[i][j].active 
            ? (sequence[i][j].rest ? 'R' : sequence[i][j].duration)
            : notes[i].name.split('/')[0];
          note.onclick = () => toggleNote(i, j, note);
          note.oncontextmenu = (e) => showContextMenu(e, i, j, note);
          if (sequence[i][j].active) note.classList.add('active');
          if (sequence[i][j].rest) note.classList.add('rest');
          if (sequence[i][j].connected) note.classList.add('connected');
          if (!sequence[i][j].active && !sequence[i][j].rest) note.classList.add('inactive-name');
          if (j % 2 === 1) note.classList.add('step-boundary');
          if (j % 8 === 7) note.classList.add('measure-boundary');
          if (j % 32 === 31) note.classList.add('section-boundary');
          sequencer.appendChild(note);
        }
      }
    }

    // 音の切り替え
    function toggleNote(row, col, element) {
      if (sequence[row][col].connected) return;
      
      sequence[row][col].active = !sequence[row][col].active;
      if (sequence[row][col].active) {
        sequence[row][col].rest = false;
        sequence[row][col].duration = defaultDuration;
        const duration = sequence[row][col].duration;
        for (let i = 1; i < Math.ceil(duration) && col + i < measures * stepsPerMeasure; i++) {
          sequence[row][col + i] = { active: false, duration: defaultDuration, connected: true, rest: false };
        }
      } else {
        for (let i = 1; i < measures * stepsPerMeasure - col; i++) {
          if (sequence[row][col + i].connected) {
            sequence[row][col + i] = { active: false, duration: defaultDuration, connected: false, rest: false };
          } else {
            break;
          }
        }
      }
      renderSequencer();
      
      if (sequence[row][col].active && !sequence[row][col].rest) {
        const instrument = document.getElementById('instrument').value;
        const tempo = parseInt(document.getElementById('tempo').value) || 120;
        const stepDuration = 60 / tempo / 8;
        playNote(notes[row], ctx.currentTime, stepDuration * sequence[row][col].duration, instrument, ctx);
      }
    }

    // コンテキストメニュー表示
    function showContextMenu(e, row, col, element) {
      e.preventDefault();
      if (sequence[row][col].connected) return;

      const existingMenu = document.querySelector('.context-menu');
      if (existingMenu) existingMenu.remove();

      const menu = document.createElement('div');
      menu.classList.add('context-menu');
      const menuWidth = 200;
      const menuHeight = 300;
      let left = e.clientX;
      let top = e.clientY;
      if (left + menuWidth > window.innerWidth) left = window.innerWidth - menuWidth;
      if (top + menuHeight > window.innerHeight) top = window.innerHeight - menuHeight;
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;
      const durations = [0.5, 1, 2, 4, 8, 16, 32, 64];
      durations.forEach(dur => {
        const item = document.createElement('div');
        item.textContent = `${dur} サブマス (${dur/2}拍)`;
        item.onclick = () => {
          updateDuration(row, col, dur, false);
          renderSequencer();
          menu.remove();
        };
        menu.appendChild(item);
      });
      const restItem = document.createElement('div');
      restItem.textContent = '休符 (1 サブマス = 0.5拍)';
      restItem.onclick = () => {
        updateDuration(row, col, 1, true);
        renderSequencer();
        menu.remove();
      };
      menu.appendChild(restItem);
      const customItem = document.createElement('div');
      customItem.innerHTML = 'カスタム: <input type="number" min="0.5" max="2000" step="0.5" value="4">';
      menu.appendChild(customItem);
      const input = customItem.querySelector('input');
      input.onchange = () => {
        const dur = parseFloat(input.value);
        if (dur >= 0.5 && dur <= 2000) {
          updateDuration(row, col, dur, false);
          renderSequencer();
        }
        menu.remove();
      };
      document.body.appendChild(menu);
      document.addEventListener('click', () => menu.remove(), { once: true });
    }

    // 音の長さ更新
    function updateDuration(row, col, duration, isRest) {
      if (notes[row].type || instrumentTypes[document.getElementById('instrument').value].type === "drum") {
        duration = Math.min(duration, 8);
      }
      for (let i = 1; i < measures * stepsPerMeasure - col; i++) {
        if (sequence[row][col + i].connected) {
          sequence[row][col + i] = { active: false, duration: defaultDuration, connected: false, rest: false };
        } else {
          break;
        }
      }
      sequence[row][col].duration = duration;
      sequence[row][col].active = true;
      sequence[row][col].rest = isRest;
      if (!isRest && duration > 1) {
        for (let i = 1; i < Math.ceil(duration) && col + i < measures * stepsPerMeasure; i++) {
          sequence[row][col + i] = { active: false, duration: defaultDuration, connected: true, rest: false };
        }
      }
    }

    // ホワイトノイズ生成（ドラム用）
    function createNoiseBuffer(ctx) {
      const bufferSize = ctx.sampleRate * 0.2;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      return buffer;
    }

    // ドラム音の生成
    function playDrum(type, startTime, duration, ctx) {
      duration = Math.min(duration, 0.3);
      if (type === "kick") {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(150, startTime);
        oscillator.frequency.exponentialRampToValueAtTime(0.001, startTime + 0.1);
        gainNode.gain.setValueAtTime(1, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.1);
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        oscillator.start(startTime);
        oscillator.stop(startTime + duration);
        oscillator.onended = () => {
          gainNode.disconnect();
          oscillator.disconnect();
        };
      } else if (type === "snare") {
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer(ctx);
        const noiseGain = ctx.createGain();
        noiseGain.gain.setValueAtTime(0.5, startTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.1);
        const oscillator = ctx.createOscillator();
        oscillator.type = "triangle";
        oscillator.frequency.setValueAtTime(200, startTime);
        const oscGain = ctx.createGain();
        oscGain.gain.setValueAtTime(0.3, startTime);
        oscGain.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.1);
        noise.connect(noiseGain);
        oscillator.connect(oscGain);
        noiseGain.connect(ctx.destination);
        oscGain.connect(ctx.destination);
        noise.start(startTime);
        oscillator.start(startTime);
        noise.stop(startTime + duration);
        oscillator.stop(startTime + duration);
        noise.onended = () => {
          noiseGain.disconnect();
          oscillator.disconnect();
          oscGain.disconnect();
        };
      } else if (type === "hihat") {
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer(ctx);
        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(0.3, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.05);
        noise.connect(gainNode);
        gainNode.connect(ctx.destination);
        noise.start(startTime);
        noise.stop(startTime + 0.05);
        noise.onended = () => {
          gainNode.disconnect();
        };
      } else if (type === "cymbal") {
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer(ctx);
        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(0.5, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.3);
        const filter = ctx.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.setValueAtTime(1000, startTime);
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(ctx.destination);
        noise.start(startTime);
        noise.stop(startTime + 0.3);
        noise.onended = () => {
          gainNode.disconnect();
          filter.disconnect();
        };
      } else if (type === "clap") {
        const noise = ctx.createBufferSource();
        noise.buffer = createNoiseBuffer(ctx);
        const gainNode = ctx.createGain();
        gainNode.gain.setValueAtTime(0.6, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.1);
        const filter = ctx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.setValueAtTime(1000, startTime);
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(ctx.destination);
        noise.start(startTime);
        noise.stop(startTime + 0.1);
        noise.onended = () => {
          gainNode.disconnect();
          filter.disconnect();
        };
      } else if (type === "tom") {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.type = "sine";
        oscillator.frequency.setValueAtTime(100, startTime);
        oscillator.frequency.exponentialRampToValueAtTime(0.001, startTime + 0.2);
        gainNode.gain.setValueAtTime(0.8, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + 0.2);
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        oscillator.start(startTime);
        oscillator.stop(startTime + 0.2);
        oscillator.onended = () => {
          gainNode.disconnect();
          oscillator.disconnect();
        };
      }
    }

    // メロディ/管楽器の生成
    function playNote(note, startTime, duration, type, ctx) {
      const instrument = instrumentTypes[type];
      if (note.type || instrument.type === "drum") {
        playDrum(note.type || type, startTime, duration, ctx);
      } else {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.type = instrument.wave || "sine";
        oscillator.frequency.setValueAtTime(note.freq, startTime);
        
        if (instrument.vibrato) {
          const vibrato = ctx.createOscillator();
          const vibratoGain = ctx.createGain();
          vibrato.frequency.setValueAtTime(instrument.vibrato.freq, startTime);
          vibratoGain.gain.setValueAtTime(note.freq * instrument.vibrato.depth, startTime);
          vibrato.connect(vibratoGain);
          vibratoGain.connect(oscillator.frequency);
          vibrato.start(startTime);
          vibrato.stop(startTime + duration + 0.05);
        }

        let filter;
        if (instrument.filter) {
          filter = ctx.createBiquadFilter();
          filter.type = instrument.filter.type;
          filter.frequency.setValueAtTime(instrument.filter.freq, startTime);
          oscillator.connect(filter);
          filter.connect(gainNode);
        } else {
          oscillator.connect(gainNode);
        }

        if (instrument.envelope) {
          const { attack, decay, sustain, release } = instrument.envelope;
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(1, startTime + attack);
          gainNode.gain.exponentialRampToValueAtTime(sustain, startTime + attack + decay);
          gainNode.gain.setValueAtTime(sustain, startTime + duration - release);
          gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + duration);
        } else {
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.005);
          gainNode.gain.setValueAtTime(0.5, startTime + duration - 0.05);
          gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + duration);
        }

        gainNode.connect(ctx.destination);
        oscillator.start(startTime);
        oscillator.stop(startTime + duration + 0.05);
        oscillator.onended = () => {
          gainNode.disconnect();
          oscillator.disconnect();
          if (filter) filter.disconnect();
          if (instrument.vibrato) vibrato.disconnect();
        };
      }
    }

    // オフライン用レンダリング
    async function renderNote(note, startTime, duration, type, ctx) {
      const instrument = instrumentTypes[type];
      if (note.type || instrument.type === "drum") {
        playDrum(note.type || type, startTime, duration, ctx);
      } else {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.type = instrument.wave || "sine";
        oscillator.frequency.setValueAtTime(note.freq, startTime);

        if (instrument.vibrato) {
          const vibrato = ctx.createOscillator();
          const vibratoGain = ctx.createGain();
          vibrato.frequency.setValueAtTime(instrument.vibrato.freq, startTime);
          vibratoGain.gain.setValueAtTime(note.freq * instrument.vibrato.depth, startTime);
          vibrato.connect(vibratoGain);
          vibratoGain.connect(oscillator.frequency);
          vibrato.start(startTime);
          vibrato.stop(startTime + duration + 0.05);
        }

        let filter;
        if (instrument.filter) {
          filter = ctx.createBiquadFilter();
          filter.type = instrument.filter.type;
          filter.frequency.setValueAtTime(instrument.filter.freq, startTime);
          oscillator.connect(filter);
          filter.connect(gainNode);
        } else {
          oscillator.connect(gainNode);
        }

        if (instrument.envelope) {
          const { attack, decay, sustain, release } = instrument.envelope;
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(1, startTime + attack);
          gainNode.gain.exponentialRampToValueAtTime(sustain, startTime + attack + decay);
          gainNode.gain.setValueAtTime(sustain, startTime + duration - release);
          gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + duration);
        } else {
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.5, startTime + 0.005);
          gainNode.gain.setValueAtTime(0.5, startTime + duration - 0.05);
          gainNode.gain.exponentialRampToValueAtTime(0.00001, startTime + duration);
        }

        gainNode.connect(ctx.destination);
        oscillator.start(startTime);
        oscillator.stop(startTime + duration + 0.05);
      }
    }

    // ハイライトの更新
    function updateHighlight(step) {
      document.querySelectorAll('.note').forEach(note => note.classList.remove('playing'));
      if (step >= 0) {
        for (let row = 0; row < notes.length; row++) {
          const note = document.querySelector(`.note[data-row="${row}"][data-col="${step}"]`);
          if (note) note.classList.add('playing');
        }
      }
    }

    // 次のステップをスケジュール
    function scheduleNotes() {
      const tempo = parseInt(document.getElementById('tempo').value) || 120;
      const stepDuration = 60 / tempo / 8;
      const instrument = document.getElementById('instrument').value;

      while (nextNoteTime < ctx.currentTime + 0.15 && isPlaying) {
        const startTime = nextNoteTime;
        for (let row = 0; row < notes.length; row++) {
          if (sequence[row][currentStep].active && !sequence[row][currentStep].rest) {
            const duration = stepDuration * sequence[row][currentStep].duration;
            playNote(notes[row], startTime, duration, instrument, ctx);
          }
        }
        updateHighlight(currentStep);
        nextNoteTime += stepDuration;
        currentStep++;
        if (currentStep >= measures * stepsPerMeasure) currentStep = 0;
      }
    }

    // シーケンスの再生
    function playSequence() {
      if (isPlaying) return;
      isPlaying = true;
      currentStep = 0;
      nextNoteTime = ctx.currentTime + 0.05;

      function scheduler() {
        if (!isPlaying) {
          updateHighlight(-1);
          return;
        }
        scheduleNotes();
        requestAnimationFrame(scheduler);
      }
      requestAnimationFrame(scheduler);
    }

    // シーケンスの停止
    function stopSequence() {
      isPlaying = false;
      updateHighlight(-1);
    }

    // 小節の追加（32サブマス＝4小節）
    function addMeasure() {
      const prevMeasureStart = (measures - 4) * stepsPerMeasure;
      const newMeasureLength = 4 * stepsPerMeasure;
      measures += 4;
      sequence = sequence.map((row, rowIndex) => {
        const newRow = [...row, ...Array(newMeasureLength).fill().map(() => ({ active: false, duration: defaultDuration, connected: false, rest: false }))];
        if (rowIndex >= melodyNotes.length && document.getElementById('autoCopyDrums').checked && prevMeasureStart >= 0) {
          for (let i = 0; i < newMeasureLength; i++) {
            newRow[prevMeasureStart + i + newMeasureLength] = { ...row[prevMeasureStart + i] };
          }
        }
        return newRow;
      });
      renderSequencer();
    }

    // 小節の削除（32サブマス＝4小節）
    function removeMeasure() {
      if (measures <= 4) return;
      measures -= 4;
      sequence = sequence.map(row => row.slice(0, measures * stepsPerMeasure));
      renderSequencer();
    }

    // 初期レンダリング
    renderSequencer();
  </script>
</body>
</html>
